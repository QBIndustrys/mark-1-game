<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BlockCrafter - Web Voxel Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://threejs.org/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #87ceeb; /* Sky blue background */
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            border-radius: 50%;
            z-index: 10;
            display: none; /* Hidden by default, shown when in game */
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex; /* Flexbox for centering content */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 2rem;
            text-align: center;
            z-index: 1000; /* High z-index to be on top */
            transition: opacity 0.5s ease-in-out;
        }
        #blocker.hidden {
            opacity: 0;
            pointer-events: none; /* Allow clicks to pass through when hidden */
        }
        #title-screen-content {
            display: flex; /* Initially visible */
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            max-width: 80%;
            max-height: 90vh; /* Make menu scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
        }
        #loading-screen-content {
            display: none; /* Hidden by default, shown during world generation */
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: absolute;
            inset: 0; /* Cover the entire screen */
            background-color: rgba(0,0,0,0.7);
        }
        #start-button {
            padding: 18px 40px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.8rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            pointer-events: auto; /* Always enabled for click-to-start */
            opacity: 1;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }
        #start-button:hover {
            background-color: #45a049;
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.6);
        }

        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background-color: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.4);
            z-index: 50;
            display: none; /* Hidden by default, shown when in game */
        }
        .toolbar-slot {
            width: 60px;
            height: 60px;
            background-size: cover;
            border: 3px solid #555;
            cursor: pointer;
            transition: all 0.2s ease;
            image-rendering: pixelated;
        }
        .toolbar-slot.active {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,255,0.7);
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: none; /* Hidden by default, shown when game is active */
            z-index: 5; /* Below blocker, above body background */
        }
        #game-container canvas {
            display: block; /* Ensure it's a block element */
            width: 100%;
            height: 100vh; /* Make sure it takes full viewport height */
        }
        #interaction-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 1rem;
            display: none; /* Hidden by default */
            z-index: 100;
        }
        #dialogue-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #dialogue-box.active {
            opacity: 1;
            display: flex;
        }
        #dialogue-content {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 1rem;
            line-height: 1.5;
        }
        #dialogue-input-container {
            display: flex;
            gap: 10px;
        }
        #dialogue-input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            background-color: rgba(255,255,255,0.1);
            color: white;
            font-size: 1rem;
            outline: none;
        }
        #dialogue-input::placeholder {
            color: rgba(255,255,255,0.6);
        }
        #dialogue-send-button, #dialogue-close-button, #suggest-idea-button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        #dialogue-send-button:hover, #dialogue-close-button:hover, #suggest-idea-button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }
        #dialogue-close-button {
            background-color: #f44336;
        }
        #dialogue-close-button:hover {
            background-color: #da190b;
        }
        #dialogue-loading-indicator {
            text-align: center;
            font-size: 1rem;
            color: #add8e6;
            display: none;
        }
    </style>
</head>
<body>

    <div id="blocker">
        <div id="title-screen-content">
            <h1 class="text-6xl font-bold mb-4 text-emerald-300 drop-shadow-lg">BlockCrafter</h1>
            <p class="text-2xl text-gray-200">A Creative Voxel Experience</p>
            <!-- The start button's text will be updated by JavaScript -->
            <button id="start-button">Click to Enter World</button> 
            <div class="text-sm mt-8 max-w-md mx-auto text-gray-300">
                <p class="font-bold text-lg mb-2 text-white">Controls</p>
                <p><strong>W, A, S, D</strong>: Move</p>
                <p><strong>Mouse</strong>: Look</p>
                <p><strong>Space</strong>: Jump</p>
                <p><strong>Left Click</strong>: Destroy Block</p>
                <p><strong>Right Click</strong>: Place Block</p>
                <p><strong>1-5 Keys</strong>: Select Block</p>
                <p><strong>E</strong>: Interact with NPC</p>
                <p><strong>ESC</strong>: Release mouse</p>
            </div>
        </div>
        <div id="loading-screen-content" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center">
            <h2 class="text-4xl text-blue-300 mb-4 animate-pulse">Generating World...</h2>
            <p class="text-xl text-gray-300">Please wait while we prepare your adventure.</p>
        </div>
    </div>
    
    <!-- New game container to hold all in-game elements -->
    <div id="game-container">
        <!-- Canvas for Three.js rendering will be appended here by JavaScript -->
        <div id="crosshair"></div>
        <div id="interaction-prompt" class="rounded-lg">Press E to Interact</div>
        <div id="toolbar"></div>
    </div>

    <div id="dialogue-box">
        <h3 class="text-2xl font-bold">NPC Dialogue ✨</h3>
        <div id="dialogue-content"></div>
        <div id="dialogue-loading-indicator">Generating response...</div>
        <div id="dialogue-input-container">
            <input type="text" id="dialogue-input" placeholder="Ask something or say hello...">
            <button id="dialogue-send-button" class="shadow-lg">Send</button>
        </div>
        <button id="suggest-idea-button" class="shadow-lg mt-2">Suggest Building Idea ✨</button>
        <button id="dialogue-close-button" class="self-end shadow-lg">Close</button>
    </div>

    <!-- Main game script -->
    <script type="module">
        // Import BufferGeometryUtils from the module
        import { BufferGeometryUtils } from 'https://threejs.org/examples/js/utils/BufferGeometryUtils.js';

        // Game Setup
        let scene, camera, renderer;
        const world = {}; // Stores block data for the entire world
        const chunks = {}; // Stores Three.js mesh objects for rendered chunks
        const chunkSize = 16; // Size of each chunk (e.g., 16x16x16 blocks)
        const renderDistance = 8; // How many chunks out from the player to render
        const simplex = new SimplexNoise('seed'); // Simplex noise for terrain generation

        // Player state
        const player = {
            height: 1.8, // Player height
            speed: 5, // Movement speed
            jumpHeight: 8, // Initial upward velocity for jump
            velocity: new THREE.Vector3(), // Current velocity (for gravity and movement)
            onGround: false, // Is the player currently on the ground?
            canMove: false  // Flag to control player movement based on pointer lock
        };
        const keyboard = {}; // Stores state of pressed keys

        // Block Interaction
        let raycaster; // For detecting intersected blocks
        let rollOverMesh, rollOverMaterial; // Visual indicator for targeted block
        let selectedBlockType;  // The type of block currently selected for placing

        let blockTypes;  // Object to store properties of each block type (color, texture)
        let toolbarBlocks;  // Array of block types available in the toolbar

        // NPC variables
        let npcMesh; // The 3D model of the NPC
        const npcInteractionDistance = 5;  // Distance within which player can interact with NPC
        let isDialogueOpen = false; // Flag to indicate if dialogue box is open
        let chatHistory = [];  // Stores conversation history for Gemini API

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const titleScreenContent = document.getElementById('title-screen-content');
        const loadingScreenContent = document.getElementById('loading-screen-content');
        const startButton = document.getElementById('start-button');
        const interactionPrompt = document.getElementById('interaction-prompt');
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueInput = document.getElementById('dialogue-input');
        const dialogueSendButton = document.getElementById('dialogue-send-button');
        const dialogueCloseButton = document.getElementById('dialogue-close-button');
        const dialogueLoadingIndicator = document.getElementById('dialogue-loading-indicator');
        const suggestIdeaButton = document.getElementById('suggest-idea-button');
        const crosshair = document.getElementById('crosshair');
        const toolbar = document.getElementById('toolbar');
        const gameContainer = document.getElementById('game-container'); // New reference to game container


        // Initialize the game when the window loads
        window.onload = function() {
            init(); // Setup Three.js, controls, UI etc.
            animate(); // Start the main animation loop immediately
        };

        // --- CORE INITIALIZATION ---
        function init() {
            console.log("init(): Game initialization started.");

            // Define block types and their textures
            blockTypes = {
                'dirt': { color: 0x8B4513, texture: createBlockTexture('#8B4513', '#A0522D') },
                'grass': { color: 0x00ff00, texture: createBlockTexture('#3A5F0B', '#556B2F', '#8B4513', false, 1.0, true) },
                'stone': { color: 0x808080, texture: createBlockTexture('#808080', '#A9A9A9') },
                'log': { color: 0x654321, texture: createBlockTexture('#654321', '#835C3B', '#5C4033', true) },
                'leaves': { color: 0x228B22, texture: createBlockTexture('#228B22', '#556B2F', null, false, 0.7) }
            };
            console.log("init(): Block types defined.");

            toolbarBlocks = ['grass', 'dirt', 'stone', 'log', 'leaves'];
            selectedBlockType = 'grass'; // Default selected block
            console.log("init(): Toolbar blocks and selected block type set.");

            // Setup Three.js Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            scene.fog = new THREE.Fog(0x87ceeb, 0, renderDistance * chunkSize); // Fog effect
            console.log("init(): Scene and fog set up.");

            // Setup Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 30; // Player starts at Y=30, terrain is typically below Y=20
            console.log("init(): Camera set up.");

            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadow mapping
            // Append renderer to the game-container, not body directly
            gameContainer.appendChild(renderer.domElement); 
            console.log("init(): Renderer attached to game-container.");

            // Setup Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc); // Soft ambient light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Sunlight-like light
            directionalLight.position.set(50, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            console.log("init(): Lighting set up.");

            // Add NPC to the scene
            addNPC();
            console.log("init(): NPC added.");

            // Setup event listeners for controls, UI, and dialogue
            setupControls();
            setupUI();
            setupDialogueListeners();
            console.log("init(): Controls, UI, and Dialogue listeners set up.");

            // Setup Raycaster for block interaction
            raycaster = new THREE.Raycaster();

            // Setup Roll-over helper (the outline that appears over blocks)
            const rollOverGeo = new THREE.BoxGeometry(1.01, 1.01, 1.01);
            rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
            rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
            scene.add(rollOverMesh);
            console.log("init(): Raycaster and rollover mesh set up.");

            // Initiate background world generation and handle start button display
            setupInitialStartScreen(); // Sets up the initial state and then starts world generation.
            console.log("init(): Initial start screen setup and world generation initiated.");

            // Add window resize listener
            window.addEventListener('resize', onWindowResize, false);
            console.log("init(): Window resize listener added. Initialization complete.");
        }

        // Manages the initial display state and triggers world generation
        function setupInitialStartScreen() {
            // Ensure blocker is visible and gameContainer is hidden
            blocker.classList.remove('hidden');
            gameContainer.style.display = 'none';

            titleScreenContent.style.display = 'none'; // Hide title content initially
            loadingScreenContent.style.display = 'flex'; // Show loading screen
            startButton.textContent = 'Generating World...'; // Indicate loading state
            startButton.style.pointerEvents = 'none'; // Disable button during loading
            startButton.style.opacity = '0.6';

            // Start world generation immediately
            startWorldGeneration().then(() => {
                // Once world is generated, hide loading screen and show title screen with active button
                loadingScreenContent.style.display = 'none';
                titleScreenContent.style.display = 'flex';
                startButton.textContent = 'Click to Enter World';
                startButton.style.pointerEvents = 'auto'; // Enable button
                startButton.style.opacity = '1';
                console.log("setupInitialStartScreen(): World generated, start button active.");
            });
            
            // Add a click listener to the *startButton* (or the whole blocker) to capture pointer lock
            // This ensures a user-initiated click which is required by browsers for pointer lock.
            startButton.addEventListener('click', async () => {
                console.log("Start button clicked. Attempting to request pointer lock.");
                try {
                    // Request pointer lock on the renderer's DOM element (the canvas)
                    await renderer.domElement.requestPointerLock();
                    console.log("Pointer lock request sent from start button click.");
                    // The pointerlockchange event will now handle UI updates and player.canMove
                } catch (error) {
                    console.error("Error requesting pointer lock from start button click:", error);
                    appendDialogue("Failed to gain mouse control: Browser might require a direct click on the game area or other interaction.");
                }
            });
        }


        // Handles the asynchronous generation of the game world
        async function startWorldGeneration() {
            console.log("startWorldGeneration(): Started.");
            // Clear all existing chunks from the scene if regenerating the world
            for (const chunkId in chunks) {
                if (chunks[chunkId].mesh) {
                    scene.remove(chunks[chunkId].mesh);
                    chunks[chunkId].mesh.traverse(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
                delete chunks[chunkId];
            }
            console.log("startWorldGeneration(): Existing chunks cleared from scene and memory.");

            player.canMove = false; // Player cannot move during generation
            crosshair.style.display = 'none'; // Hide crosshair during loading/menu
            toolbar.style.display = 'none'; // Hide toolbar during loading/menu
            console.log("startWorldGeneration(): Ensuring game UI is hidden.");

            // Allow the UI to update visually before starting heavy computation
            await new Promise(resolve => setTimeout(resolve, 100));

            // Determine player's starting chunk position
            // Reset player position for a fresh world
            camera.position.set(0, 30, 0); 
            const playerChunkX = Math.floor(camera.position.x / chunkSize);
            const playerChunkZ = Math.floor(camera.position.z / chunkSize);
            console.log(`startWorldGeneration(): Generating chunks around player at (${playerChunkX}, ${playerChunkZ}).`);

            // Generate chunks within the render distance
            for (let x = playerChunkX - renderDistance; x <= playerChunkX + renderDistance; x++) {
                for (let z = playerChunkZ - renderDistance; z <= playerChunkZ + renderDistance; z++) {
                    await new Promise(resolve => setTimeout(resolve, 5)); // Small delay for smoother loading animation (visual feedback)
                    generateChunk(x, z);
                }
            }
            console.log("startWorldGeneration(): All initial chunks generated.");

            // This function is now only responsible for generation. UI updates are handled by setupInitialStartScreen
        }


        // Sets up all global control listeners (keyboard, mouse)
        function setupControls() {
            console.log("setupControls(): Setting up control listeners.");
            // Listen for pointer lock state changes
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    // Pointer lock acquired: enter game mode
                    console.log("pointerlockchange: Pointer lock acquired. Hiding blocker, showing gameContainer, enabling movement, showing game UI.");
                    blocker.classList.add('hidden'); // Hide the menu blocker
                    gameContainer.style.display = 'block'; // Show the game container
                    player.canMove = true; // Enable player movement
                    crosshair.style.display = 'block'; // Show crosshair
                    toolbar.style.display = 'flex'; // Show toolbar
                } else {
                    // Pointer lock lost: return to menu mode
                    console.log("pointerlockchange: Pointer lock lost. Showing blocker, hiding gameContainer, disabling movement, hiding game UI.");
                    blocker.classList.remove('hidden'); // Show the menu blocker
                    gameContainer.style.display = 'none'; // Hide the game container
                    player.canMove = false; // Disable player movement
                    crosshair.style.display = 'none'; // Hide crosshair
                    toolbar.style.display = 'none'; // Hide toolbar
                    
                    // Only re-initiate world generation if not already in dialogue (which would prevent pointer lock)
                    if (!isDialogueOpen) {
                        titleScreenContent.style.display = 'flex';
                        loadingScreenContent.style.display = 'none'; // Ensure loading screen is hidden
                        startButton.textContent = 'Click to Enter World'; // Update button text
                        startButton.style.pointerEvents = 'auto'; // Enable button
                        startButton.style.opacity = '1';
                        // Re-trigger world generation for a clean state on next play
                        startWorldGeneration(); 
                    } else {
                         // If dialogue is open, player.canMove is already false, and blocker is visible due to dialogue
                         console.log("pointerlockchange: Pointer lock lost, but dialogue is open. Maintaining dialogue state.");
                    }
                }
            });
            
            // Keyboard event listeners
            document.addEventListener('keydown', (e) => {
                keyboard[e.code] = true; // Mark key as pressed
                // If 'E' is pressed, not in dialogue, and player can move (in game)
                if (e.code === 'KeyE' && !isDialogueOpen && player.canMove) {
                    const distance = camera.position.distanceTo(npcMesh.position);
                    if (distance < npcInteractionDistance) {
                        openDialogue(); // Open NPC dialogue
                    }
                }
            });
            document.addEventListener('keyup', (e) => keyboard[e.code] = false); // Mark key as released

            // Mouse movement for camera rotation
            document.addEventListener('mousemove', (event) => {
                // Only rotate camera if pointer is locked and player can move
                if (document.pointerLockElement === renderer.domElement && player.canMove) {
                    camera.rotation.y -= event.movementX * 0.002; // Yaw
                    camera.rotation.x -= event.movementY * 0.002; // Pitch
                    // Clamp pitch to prevent flipping
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });
            
            // Mouse clicks for block interaction
            document.addEventListener('mousedown', (event) => {
                // Only interact if pointer is locked, not in dialogue, and player can move
                if (document.pointerLockElement !== renderer.domElement || isDialogueOpen || !player.canMove) return;
                if (event.button === 2) event.preventDefault(); // Prevent right-click context menu

                if (event.button === 0) {  // Left click: Destroy block
                    destroyBlock();
                } else if (event.button === 2) {  // Right click: Place block
                    placeBlock();
                }
            });

            // Prevent browser's default right-click context menu on the canvas
            renderer.domElement.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
            console.log("setupControls(): Control listeners attached.");
        }
        
        // Sets up the toolbar UI elements and their click handlers
        function setupUI() {
            console.log("setupUI(): Setting up toolbar UI.");
            const toolbar = document.getElementById('toolbar');
            toolbar.innerHTML = '';  // Clear any existing toolbar items
            toolbarBlocks.forEach((type, index) => {
                const slot = document.createElement('div');
                slot.classList.add('toolbar-slot');
                if (index === 0) slot.classList.add('active'); // Set first slot as active by default
                slot.dataset.blockType = type; // Store block type in dataset
                
                // Set background image from block texture's canvas DataURL
                const blockTextureObject = blockTypes[type];
                if (blockTextureObject && blockTextureObject.texture && blockTextureObject.texture.image) {
                    if (blockTextureObject.texture.image.complete) {
                        slot.style.backgroundImage = `url(${blockTextureObject.texture.image.toDataURL()})`;
                    } else {
                        // If texture is not yet loaded, wait for it
                        blockTextureObject.texture.image.onload = () => {
                            slot.style.backgroundImage = `url(${blockTextureObject.texture.image.toDataURL()})`;
                        };
                    }
                } else {
                    console.warn(`setupUI(): Missing texture image for block type: ${type}`);
                }
                
                slot.addEventListener('click', () => {
                    selectBlock(type); // Select block when slot is clicked
                });
                toolbar.appendChild(slot);
            });

            // Keyboard shortcuts (1-5 keys) for selecting blocks
            window.addEventListener('keydown', (e) => {
                if (e.code.startsWith('Digit')) {
                    const index = parseInt(e.code.slice(5)) - 1; // Convert key code to 0-indexed number
                    if (index >= 0 && index < toolbarBlocks.length) {
                        selectBlock(toolbarBlocks[index]);
                    }
                }
            });
            console.log("setupUI(): Toolbar UI setup complete.");
        }

        // Changes the currently selected block type
        function selectBlock(type) {
            console.log(`selectBlock(): Selected block type: ${type}`);
            selectedBlockType = type;
            // Update active class for visual feedback on toolbar
            document.querySelectorAll('.toolbar-slot').forEach(slot => {
                slot.classList.toggle('active', slot.dataset.blockType === type);
            });
        }

        // Generates a canvas texture for a block face with given colors
        function createBlockTexture(color, highlight, topColor = null, isLog = false, opacity = 1.0, isGrass = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const context = canvas.getContext('2d');

            context.fillStyle = color;
            context.fillRect(0, 0, 16, 16);

            context.strokeStyle = 'rgba(0,0,0,0.2)';
            context.lineWidth = 1;
            context.strokeRect(0.5, 0.5, 15, 15);

            context.fillStyle = highlight;
            for(let i = 0; i < 20; i++){
                context.fillRect(Math.random() * 16, Math.random() * 16, 1, 1);
            }
            
            const baseTexture = new THREE.CanvasTexture(canvas);
            baseTexture.magFilter = THREE.NearestFilter;
            baseTexture.minFilter = THREE.NearestFilter;
            baseTexture.colorSpace = THREE.SRGBColorSpace;
            
            let topTexture = baseTexture;
            if (topColor) {
                 const topCanvas = document.createElement('canvas');
                 topCanvas.width = 16;
                 topCanvas.height = 16;
                 const topContext = topCanvas.getContext('2d');
                 topContext.fillStyle = topColor;
                 topContext.fillRect(0, 0, 16, 16);
                 topContext.fillStyle = highlight;
                 for(let i = 0; i < 20; i++){
                     topContext.fillRect(Math.random() * 16, Math.random() * 16, 2, 2);
                 }
                 topTexture = new THREE.CanvasTexture(topCanvas);
                 topTexture.magFilter = THREE.NearestFilter;
                 topTexture.minFilter = THREE.NearestFilter;
                 topTexture.colorSpace = THREE.SRGBColorSpace;
            }
            
            let sideTexture = baseTexture;
            if (isLog){
                 const sideCanvas = document.createElement('canvas');
                 sideCanvas.width = 16;
                 sideCanvas.height = 16;
                 const sideContext = sideCanvas.getContext('2d');
                 sideContext.fillStyle = color;
                 sideContext.fillRect(0, 0, 16, 16);
                 sideContext.strokeStyle = 'rgba(0,0,0,0.4)';
                 sideContext.lineWidth = 2;
                 for(let y = 0; y < 16; y+=4) {
                    sideContext.beginPath();
                    sideContext.moveTo(0, y + Math.random()*2-1);
                    sideContext.bezierCurveTo(5, y + Math.random()*2-1, 11, y + Math.random()*2-1, 16, y + Math.random()*2-1);
                    sideContext.stroke();
                 }
                 sideTexture = new THREE.CanvasTexture(sideCanvas);
                 sideTexture.magFilter = THREE.NearestFilter;
                 sideTexture.minFilter = THREE.NearestFilter;
                 sideTexture.colorSpace = THREE.SRGBColorSpace;
            }

            let grassSideTexture = sideTexture;
            if (isGrass) {
                const grassSideCanvas = document.createElement('canvas');
                grassSideCanvas.width = 16;
                grassSideCanvas.height = 16;
                const grassSideContext = grassSideCanvas.getContext('2d');

                grassSideContext.fillStyle = topColor;
                grassSideContext.fillRect(0, 0, 16, 6);
                grassSideContext.fillStyle = highlight;
                for(let i = 0; i < 10; i++){
                    grassSideContext.fillRect(Math.random() * 16, Math.random() * 6, 1, 1);
                }

                grassSideContext.fillStyle = '#8B4513';
                grassSideContext.fillRect(0, 6, 16, 10);
                grassSideContext.fillStyle = '#A0522D';
                for(let i = 0; i < 15; i++){
                    grassSideContext.fillRect(Math.random() * 16, 6 + Math.random() * 10, 1, 1);
                }

                grassSideTexture = new THREE.CanvasTexture(grassSideCanvas);
                grassSideTexture.magFilter = THREE.NearestFilter;
                grassSideTexture.minFilter = THREE.NearestFilter;
                grassSideTexture.colorSpace = THREE.SRGBColorSpace;
            }

            // Return an array of materials for each face of the cube
            const material = [
                new THREE.MeshLambertMaterial({ map: isGrass ? grassSideTexture : sideTexture, transparent: opacity < 1.0, opacity: opacity }),  // right face
                new THREE.MeshLambertMaterial({ map: isGrass ? grassSideTexture : sideTexture, transparent: opacity < 1.0, opacity: opacity }),  // left face
                new THREE.MeshLambertMaterial({ map: topTexture, transparent: opacity < 1.0, opacity: opacity }),  // top face
                new THREE.MeshLambertMaterial({ map: baseTexture, transparent: opacity < 1.0, opacity: opacity }),  // bottom face (always dirt for grass)
                new THREE.MeshLambertMaterial({ map: isGrass ? grassSideTexture : sideTexture, transparent: opacity < 1.0, opacity: opacity }),  // front face
                new THREE.MeshLambertMaterial({ map: isGrass ? grassSideTexture : sideTexture, transparent: opacity < 1.0, opacity: opacity })    // back face
            ];

            return { texture: baseTexture, material: material }; // Return baseTexture for toolbar, and the array of materials
        }

        // --- WORLD GENERATION ---
        // Generates a single chunk's block data and creates its 3D mesh
        function generateChunk(chunkX, chunkZ) {
            const chunkId = `${chunkX},${chunkZ}`;
            if (chunks[chunkId]) {
                return; // Chunk already exists, skip generation
            }

            const chunkData = new Uint8Array(chunkSize * chunkSize * chunkSize); // Stores block types for this chunk
            
            // Populate chunk data using Simplex Noise for terrain height
            for (let x = 0; x < chunkSize; x++) {
                for (let z = 0; z < chunkSize; z++) {
                    const worldX = chunkX * chunkSize + x;
                    const worldZ = chunkZ * chunkSize + z;

                    // Combine multiple noise layers for more varied terrain
                    const height1 = simplex.noise2D(worldX / 50, worldZ / 50) * 10;
                    const height2 = simplex.noise2D(worldX / 20, worldZ / 20) * 5; // Finer details
                    const height = Math.floor(height1 + height2) + 10; // Base height + noise

                    for (let y = 0; y < chunkSize; y++) {
                         if (y < height) {
                            let blockType;
                            // Assign block types based on height
                            if (y === height - 1) blockType = 'grass';
                            else if (y >= height - 4) blockType = 'dirt';
                            else blockType = 'stone';
                            setBlock(chunkData, x, y, z, toolbarBlocks.indexOf(blockType) + 1); // Store block type index
                         }
                    }
                    // Randomly generate trees
                    if(Math.random() < 0.005) {
                         generateTree(chunkData, x, height, z);
                    }
                }
            }
            
            const chunkMesh = createChunkMesh(chunkData); // Create the 3D mesh for this chunk
            if (chunkMesh) {
                chunkMesh.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize); // Position the mesh
                scene.add(chunkMesh); // Add to Three.js scene
                chunks[chunkId] = { // Store chunk data and mesh
                    data: chunkData,
                    mesh: chunkMesh,
                };
            } else {
                console.warn(`generateChunk(): Chunk ${chunkId} mesh was not created or was empty.`);
            }
        }
        
        // Generates a tree structure within a chunk
        function generateTree(chunkData, x, y, z) {
            const treeHeight = 4 + Math.floor(Math.random() * 3); // Random tree height
            // Place log blocks for the trunk
            for(let i=0; i < treeHeight; i++){
                setBlock(chunkData, x, y+i, z, toolbarBlocks.indexOf('log') + 1);
            }
            
            // Place leaves around the top of the trunk
            const leavesRadius = 2;
            for(let ly = y + treeHeight - 2; ly < y + treeHeight + 2; ly++){
                for(let lx = x - leavesRadius; lx <= x + leavesRadius; lx++){
                    for(let lz = z - leavesRadius; lz <= z + leavesRadius; lz++){
                        const dist = Math.sqrt(Math.pow(lx-x, 2) + Math.pow(ly-(y+treeHeight-1), 2) + Math.pow(lz-z, 2));
                        // Place leaves if within radius and block is currently air
                        if(dist < leavesRadius + 0.5 && getBlock(chunkData, lx, ly, lz) === 0){
                           setBlock(chunkData, lx, ly, lz, toolbarBlocks.indexOf('leaves') + 1);
                        }
                    }
                }
            }
        }
        
        // Gets the block type at local chunk coordinates (0 for air)
        function getBlock(chunkData, x, y, z) {
            if (x < 0 || x >= chunkSize || y < 0 || y >= chunkSize || z < 0 || z >= chunkSize) {
                return 0; // Out of bounds is considered air
            }
            return chunkData[y * chunkSize * chunkSize + z * chunkSize + x];
        }

        // Sets the block type at local chunk coordinates
        function setBlock(chunkData, x, y, z, type) {
            if (x < 0 || x >= chunkSize || y < 0 || y >= chunkSize || z < 0 || z >= chunkSize) {
                return; // Do nothing if out of bounds
            }
            chunkData[y * chunkSize * chunkSize + z * chunkSize + x] = type;
        }

        // Creates a merged Three.js mesh for a chunk's visible blocks
        function createChunkMesh(chunkData) {
            const geometries = {}; // Stores geometries for each block type
            toolbarBlocks.forEach(type => {
                geometries[type] = [];
            });
            const cubeGeo = new THREE.BoxGeometry(1, 1, 1); // Reusable cube geometry for individual blocks
            
            let totalFacesAdded = 0; // Debugging count
            for (let y = 0; y < chunkSize; y++) {
                for (let z = 0; z < chunkSize; z++) {
                    for (let x = 0; x < chunkSize; x++) {
                        const blockTypeIndex = getBlock(chunkData, x, y, z);
                        if (blockTypeIndex === 0) continue; // Skip air blocks

                        const blockTypeName = toolbarBlocks[blockTypeIndex - 1]; // Get block name from index

                        // Check neighbors to determine if a face is visible (simple culling)
                        if (getBlock(chunkData, x + 1, y, z) === 0 || // Right
                            getBlock(chunkData, x - 1, y, z) === 0 || // Left
                            getBlock(chunkData, x, y + 1, z) === 0 || // Top
                            getBlock(chunkData, x, y - 1, z) === 0 || // Bottom
                            getBlock(chunkData, x, y, z + 1) === 0 || // Front
                            getBlock(chunkData, x, y, z - 1) === 0)    // Back
                        {
                            const matrix = new THREE.Matrix4();
                            matrix.makeTranslation(x, y, z); // Position the cube
                            const newGeo = cubeGeo.clone();
                            newGeo.applyMatrix4(matrix); // Apply position to geometry
                            geometries[blockTypeName].push(newGeo); // Add to array for merging
                            totalFacesAdded++;
                        }
                    }
                }
            }

            const chunkGroup = new THREE.Group(); // Group to hold all merged meshes for this chunk
            for(const type in geometries) {
                if(geometries[type].length > 0) {
                    // Merge all geometries of the same block type into a single buffer geometry
                    const mergedGeo = BufferGeometryUtils.mergeBufferGeometries(geometries[type]); 
                    if(mergedGeo) {
                        const material = blockTypes[type].texture.material; // Get material for this block type
                        const mesh = new THREE.Mesh(mergedGeo, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        chunkGroup.add(mesh); // Add merged mesh to the chunk group
                    } else {
                         // This warning can happen if mergeBufferGeometries receives an empty array, which should be caught by `geometries[type].length > 0`
                         // or if there's a problem with BufferGeometryUtils itself.
                         // console.warn(`createChunkMesh: mergeBufferGeometries returned null for type ${type}.`);
                    }
                }
            }
            
            cubeGeo.dispose(); // Dispose of the temporary cube geometry
            // If no faces were added but chunkGroup is empty, it means there was an issue or no visible blocks
            if (chunkGroup.children.length === 0 && totalFacesAdded > 0) {
                console.warn("createChunkMesh: Chunk group is empty even though faces were added. Possible merging issue.");
                return null;
            } else if (chunkGroup.children.length === 0) {
                 // console.log("createChunkMesh: No exposed faces in this chunk, returning null mesh.");
                 return null; // Return null if the chunk is completely empty or has no visible faces
            }
            return chunkGroup;
        }
        
        // Dynamically loads and unloads chunks based on player position
        function updateChunks() {
            const playerChunkX = Math.floor(camera.position.x / chunkSize);
            const playerChunkZ = Math.floor(camera.position.z / chunkSize);

            // Generate new chunks around the player
            for (let x = playerChunkX - renderDistance; x <= playerChunkX + renderDistance; x++) {
                for (let z = playerChunkZ - renderDistance; z <= playerChunkZ + renderDistance; z++) {
                    generateChunk(x, z);
                }
            }
            
            // Unload distant chunks to save memory and performance
            for (const chunkId in chunks) {
                const [cx, cz] = chunkId.split(',').map(Number);
                const dx = Math.abs(cx - playerChunkX);
                const dz = Math.abs(cz - playerChunkZ);
                // If chunk is outside render distance, remove it
                if (dx > renderDistance || dz > renderDistance) {
                    scene.remove(chunks[chunkId].mesh);
                    chunks[chunkId].mesh.traverse(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    delete chunks[chunkId];
                }
            }
        }
        
        // Gets the block type at global world coordinates
        function getWorldBlock(x, y, z) {
            const chunkX = Math.floor(x / chunkSize);
            const chunkZ = Math.floor(z / chunkSize);
            const chunkId = `${chunkX},${chunkZ}`;
            const chunk = chunks[chunkId];

            if(!chunk) return 0; // If chunk doesn't exist, assume air

            const localX = x - chunkX * chunkSize;
            const localY = y;
            const localZ = z - chunkZ * chunkSize;

            return getBlock(chunk.data, localX, localY, localZ);
        }

        // Sets the block type at global world coordinates, and triggers chunk regeneration
        function setWorldBlock(x, y, z, type) {
            console.log(`setWorldBlock(): Setting block at (${x},${y},${z}) to type ${type}.`);
            const chunkX = Math.floor(x / chunkSize);
            const chunkZ = Math.floor(z / chunkSize);
            const chunkId = `${chunkX},${chunkZ}`;
            let chunk = chunks[chunkId];

            // If the target chunk doesn't exist, generate it first
            if (!chunk) {
                console.log(`setWorldBlock(): Chunk ${chunkId} not found, generating.`);
                generateChunk(chunkX, chunkZ);
                chunk = chunks[chunkId];
                if (!chunk) {
                    console.warn(`setWorldBlock(): Failed to generate chunk ${chunkId} for block placement.`);
                    return; // Cannot set block if chunk couldn't be generated
                }
            }

            const localX = x - chunkX * chunkSize;
            const localY = y;
            const localZ = z - chunkZ * chunkSize;
            
            setBlock(chunk.data, localX, localY, localZ, type);
            
            // Regenerate the chunk where the block was changed
            regenerateChunk(chunkX, chunkZ);

            // Also regenerate neighboring chunks if the block change was at a chunk border,
            // as it affects their visible faces (culling)
            if (localX === 0) regenerateChunk(chunkX - 1, chunkZ);
            if (localX === chunkSize - 1) regenerateChunk(chunkX + 1, chunkZ);
            if (localZ === 0) regenerateChunk(chunkX, chunkZ - 1);
            if (localZ === chunkSize - 1) regenerateChunk(chunkX, chunkZ + 1);
        }

        // Recreates and replaces the 3D mesh for a specific chunk
        function regenerateChunk(chunkX, chunkZ) {
            const chunkId = `${chunkX},${chunkZ}`;
            const chunk = chunks[chunkId];
            if(!chunk) {
                return; // Nothing to regenerate if chunk doesn't exist
            }
            console.log(`regenerateChunk(): Regenerating chunk ${chunkId}.`);

            // Remove old mesh from scene and dispose its resources
            scene.remove(chunk.mesh);
            chunk.mesh.traverse(child => {
                if(child.isMesh) {
                    child.geometry.dispose();
                    if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            });
            
            // Create new mesh from updated chunk data
            const newMesh = createChunkMesh(chunk.data);
            if (newMesh) {
                newMesh.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);
                scene.add(newMesh);
                chunk.mesh = newMesh; // Update reference to new mesh
                console.log(`regenerateChunk(): New mesh for chunk ${chunkId} added.`);
            } else {
                console.warn(`regenerateChunk(): New mesh for chunk ${chunkId} was null (empty chunk?). Deleting chunk entry.`);
                delete chunks[chunkId]; // Remove chunk from map if it became empty
            }
        }

        // --- BLOCK INTERACTION ---
        // Uses raycasting to find the first intersected 3D object
        function getIntersectedObject() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            // Collect all chunk meshes and NPC for intersection testing
            const interactiveObjects = Object.values(chunks).map(c => c.mesh);
            if (npcMesh) interactiveObjects.push(npcMesh);

            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            if (intersects.length > 0) {
                // Filter out NPC for block interaction, unless it's the only thing hit
                const blockIntersects = intersects.filter(i => i.object !== npcMesh);
                if (blockIntersects.length > 0) {
                    return blockIntersects[0];
                }
                // If only NPC is intersected and we are not in dialogue mode, don't return it for block interaction
                if (intersects[0].object === npcMesh && !isDialogueOpen) {
                    return null;
                }
                return intersects[0]; // Return the NPC if it's the only intersection and relevant
            }
            return null; // No intersection
        }

        // Handles destroying a block when left-clicked
        function destroyBlock() {
            console.log("destroyBlock(): Attempting to destroy block.");
            const intersect = getIntersectedObject();
            // Check if an object was intersected and it's within interaction distance
            if (intersect && intersect.distance < 6) {
                // Calculate block position: move half a block back along the normal to get the block's center
                const pos = new THREE.Vector3().copy(intersect.point).sub(intersect.face.normal.multiplyScalar(0.5));
                const blockPos = {
                    x: Math.floor(pos.x),
                    y: Math.floor(pos.y),
                    z: Math.floor(pos.z)
                };
                setWorldBlock(blockPos.x, blockPos.y, blockPos.z, 0); // Set block type to 0 (air)
                console.log(`destroyBlock(): Block destroyed at ${blockPos.x}, ${blockPos.y}, ${blockPos.z}`);
            } else {
                console.log("destroyBlock(): No block intersected or too far.");
            }
        }

        // Handles placing a block when right-clicked
        function placeBlock() {
            console.log("placeBlock(): Attempting to place block.");
            const intersect = getIntersectedObject();
            // Check if an object was intersected and it's within interaction distance
            if (intersect && intersect.distance < 6) {
                // Calculate block position: move half a block forward along the normal to place next to it
                const pos = new THREE.Vector3().copy(intersect.point).add(intersect.face.normal.multiplyScalar(0.5));
                const blockPos = {
                    x: Math.floor(pos.x),
                    y: Math.floor(pos.y),
                    z: Math.floor(pos.z)
                };
                
                // Create a temporary bounding box for the player for collision check
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(camera.position.x, camera.position.y - player.height / 2, camera.position.z),
                    new THREE.Vector3(0.6, player.height, 0.6)
                );
                // Create a bounding box for the new block being placed
                const blockBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(blockPos.x + 0.5, blockPos.y + 0.5, blockPos.z + 0.5), new THREE.Vector3(1,1,1));
                
                // Only place block if it doesn't intersect with the player's current position
                if(!playerBox.intersectsBox(blockBox)){
                    setWorldBlock(blockPos.x, blockPos.y, blockPos.z, toolbarBlocks.indexOf(selectedBlockType) + 1);
                    console.log(`placeBlock(): Block placed at ${blockPos.x}, ${blockPos.y}, ${blockPos.z} of type ${selectedBlockType}`);
                } else {
                    console.log("placeBlock(): Cannot place block, player is inside target block area.");
                }
            } else {
                console.log("placeBlock(): No valid intersection for placing block.");
            }
        }

        // --- NPC Logic ---
        // Adds a simple NPC model to the scene
        function addNPC() {
            console.log("addNPC(): Adding NPC to scene.");
            const npcGeometry = new THREE.BoxGeometry(1, 2, 1);
            const npcMaterial = new THREE.MeshLambertMaterial({ color: 0x8A2BE2 });
            npcMesh = new THREE.Mesh(npcGeometry, npcMaterial);
            npcMesh.position.set(0, 10, -5); // Position the NPC
            scene.add(npcMesh);

            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFA07A });
            const headMesh = new THREE.Mesh(headGeometry, headMaterial);
            headMesh.position.y = 1.4; // Position head relative to body
            npcMesh.add(headMesh);
            console.log("addNPC(): NPC added successfully.");
        }

        // Checks if player is close enough to interact with NPC and shows prompt
        function checkNPCInteraction() {
            if (npcMesh && !isDialogueOpen) {
                const distance = camera.position.distanceTo(npcMesh.position);
                if (distance < npcInteractionDistance) {
                    interactionPrompt.style.display = 'block';
                } else {
                    interactionPrompt.style.display = 'none';
                }
            } else if (isDialogueOpen) {
                interactionPrompt.style.display = 'none';
            }
        }

        // Opens the NPC dialogue box
        function openDialogue() {
            console.log("openDialogue(): Opening dialogue box.");
            isDialogueOpen = true;
            dialogueBox.classList.add('active');
            player.canMove = false; // Disable player movement while in dialogue
            if (document.pointerLockElement) {
                document.exitPointerLock(); // Release pointer lock
            }

            // Display initial greeting if it's a new conversation
            if (chatHistory.length === 0) {
                appendDialogue('NPC: Hello, traveler! What brings you to these blocky lands?');
            }
            dialogueInput.focus(); // Focus on the input field
        }

        // Closes the NPC dialogue box
        function closeDialogue() {
            console.log("closeDialogue(): Closing dialogue box.");
            isDialogueOpen = false;
            dialogueBox.classList.remove('active');
            player.canMove = true; // Re-enable player movement
            dialogueContent.innerHTML = ''; // Clear chat display
            chatHistory = []; // Clear chat history
            // Attempt to re-lock pointer after closing dialogue
            if (document.pointerLockElement === null) {
                renderer.domElement.requestPointerLock();
            }
        }

        // Sets up event listeners for dialogue box buttons and input
        function setupDialogueListeners() {
            dialogueSendButton.addEventListener('click', sendDialogue);
            dialogueInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendDialogue();
                }
            });
            dialogueCloseButton.addEventListener('click', closeDialogue);
            suggestIdeaButton.addEventListener('click', suggestBuildingIdea); // Listener for new idea button
        }

        // Sends player's message to Gemini API and displays NPC response
        async function sendDialogue() {
            const userMessage = dialogueInput.value.trim();
            if (userMessage === '') return;

            appendDialogue(`You: ${userMessage}`);
            dialogueInput.value = '';
            dialogueLoadingIndicator.style.display = 'block';
            dialogueContent.scrollTop = dialogueContent.scrollHeight; // Scroll to bottom

            chatHistory.push({ role: "user", parts: [{ text: userMessage }] }); // Add to conversation history

            try {
                const apiKey = ""; // Canvas will automatically provide this
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const payload = {
                    contents: chatHistory
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                dialogueLoadingIndicator.style.display = 'none';

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const llmResponse = result.candidates[0].content.parts[0].text;
                    appendDialogue(`NPC: ${llmResponse}`);
                    chatHistory.push({ role: "model", parts: [{ text: llmResponse }] }); // Store model's response
                } else {
                    appendDialogue("NPC: I'm sorry, I couldn't understand that. Could you please rephrase?");
                }
            } catch (error) {
                dialogueLoadingIndicator.style.display = 'none';
                appendDialogue("NPC: I seem to be disconnected from the world. Please try again later.");
            }
            dialogueContent.scrollTop = dialogueContent.scrollHeight; // Scroll to bottom again
        }

        // Prompts Gemini API for a building idea based on available blocks
        async function suggestBuildingIdea() {
            appendDialogue(`NPC: Let me think...`);
            dialogueLoadingIndicator.style.display = 'block';
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            const availableBlocks = toolbarBlocks.join(', '); // Get list of available blocks
            const prompt = `You are a creative architect and world-builder in a voxel game. Given the available block types: ${availableBlocks}, suggest a creative and inspiring structure or object the player can build. Keep your suggestion concise and imaginative, focusing on the visual and functional aspects.`;

            // Create a fresh chat history for this specific idea generation prompt
            let ideaChatHistory = [{ role: "user", parts: [{ text: prompt }] }];

            try {
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const payload = {
                    contents: ideaChatHistory
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                dialogueLoadingIndicator.style.display = 'none';

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const llmResponse = result.candidates[0].content.parts[0].text;
                    appendDialogue(`NPC: How about this idea for you: ${llmResponse}`);
                } else {
                    appendDialogue("NPC: My creative circuits seem a bit jammed. Try asking me again!");
                }
            } catch (error) {
                dialogueLoadingIndicator.style.display = 'none';
                appendDialogue("NPC: I can't think of anything right now. Perhaps later?");
            }
            dialogueContent.scrollTop = dialogueContent.scrollHeight;
        }

        // Appends a new message to the dialogue box display
        function appendDialogue(message) {
            const p = document.createElement('p');
            p.textContent = message;
            dialogueContent.appendChild(p);
        }

        // --- GAME LOOP ---
        let lastTime = performance.now(); // Stores time of last frame for delta calculation
        function animate() {
            requestAnimationFrame(animate); // Request next frame

            const time = performance.now();
            const delta = (time - lastTime) / 1000; // Time elapsed since last frame in seconds

            // Only update player and chunks if pointer is locked and player movement is enabled
            if (document.pointerLockElement === renderer.domElement && player.canMove) {
                updatePlayer(delta); // Update player position and physics
                updateChunks(); // Manage chunk loading/unloading
            } else if (document.pointerLockElement !== renderer.domElement && player.canMove) {
                // Fallback: if player.canMove is true but pointer lock is lost, correct the state
                player.canMove = false;
                crosshair.style.display = 'none'; // Hide crosshair
                toolbar.style.display = 'none'; // Hide toolbar
                console.log("animate(): Player movement disabled due to detected pointer lock discrepancy. State corrected.");
            }
            
            checkNPCInteraction(); // Update NPC interaction prompt visibility

            const intersect = getIntersectedObject(); // Get currently targeted object
            // Show roll-over mesh if a block (not NPC) is targeted within range and dialogue is not open
            if (intersect && intersect.object !== npcMesh && intersect.distance < 6 && !isDialogueOpen) {
                rollOverMesh.visible = true;
                // Position roll-over mesh on the targeted block
                const pos = new THREE.Vector3().copy(intersect.point).sub(intersect.face.normal.multiplyScalar(0.5));
                rollOverMesh.position.set(Math.floor(pos.x) + 0.5, Math.floor(pos.y) + 0.5, Math.floor(pos.z) + 0.5);
            } else {
                rollOverMesh.visible = false; // Hide roll-over mesh
            }

            renderer.render(scene, camera); // Render the scene
            lastTime = time; // Update last frame time
        }
        
        // Updates player's position, applies gravity, and handles collisions
        function updatePlayer(delta) {
            // Apply gravity to vertical velocity
            player.velocity.y -= 9.8 * 2.0 * delta; // Gravity constant * a multiplier for faster fall

            let moveSpeed = player.speed * delta; // Calculate movement distance for this frame
            let moveDirection = new THREE.Vector3(); // Vector for player input direction

            // Determine input direction based on keyboard state
            if (keyboard['KeyW']) moveDirection.z = -1;
            if (keyboard['KeyS']) moveDirection.z = 1;
            if (keyboard['KeyA']) moveDirection.x = -1;
            if (keyboard['KeyD']) moveDirection.x = 1;
            
            // Normalize movement direction to prevent faster diagonal movement
            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize();
            }

            // Apply camera's yaw (horizontal rotation) to movement direction
            const cameraYaw = new THREE.Euler(0, camera.rotation.y, 0, 'XYZ');
            moveDirection.applyEuler(cameraYaw);

            // Calculate movement components for X and Z axes
            const moveX = moveDirection.x * moveSpeed;
            const moveZ = moveDirection.z * moveSpeed;
            
            const oldPosition = camera.position.clone(); // Store current position for collision rollback

            // Apply movement and check for collisions for X-axis
            camera.position.x += moveX;
            if(checkCollision()){
                camera.position.x = oldPosition.x; // Rollback if collision
                player.velocity.x = 0; // Stop horizontal velocity
            }

            // Apply movement and check for collisions for Z-axis
            camera.position.z += moveZ;
            if(checkCollision()){
                camera.position.z = oldPosition.z; // Rollback if collision
                player.velocity.z = 0; // Stop horizontal velocity
            }

            // Apply vertical movement and check for collisions (Y-axis)
            camera.position.y += player.velocity.y * delta;
            if (checkCollision()) {
                if (player.velocity.y < 0) { // If player is falling and hits ground
                    // Move player just on top of the collided block
                    const playerFeetY = camera.position.y - player.height / 2;
                    const blockY = Math.floor(playerFeetY); // The Y coordinate of the block below
                    camera.position.y = blockY + 1 + (player.height / 2) + 0.01; // Position on top of the block + small epsilon
                    player.onGround = true; // Mark player as on ground
                } else if (player.velocity.y > 0) { // If player is jumping and hits ceiling
                    camera.position.y = oldPosition.y; // Rollback to prevent getting stuck in ceiling
                }
                player.velocity.y = 0; // Stop vertical velocity on collision
            } else {
                player.onGround = false; // Player is in the air
            }
            
            // Handle jumping input
            if (keyboard['Space'] && player.onGround) {
                player.velocity.y = player.jumpHeight; // Apply upward velocity
                player.onGround = false; // Player is now in the air
            }
        }
        
        // Checks for collision between player's bounding box and world blocks
        function checkCollision() {
            // Player's bounding box for collision detection
            // Center is at camera.position.x, camera.position.y - (player.height / 2), camera.position.z
            // Size is 0.6 for width/depth and player.height * 0.9 for height (slightly smaller to prevent edge-sticking)
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(camera.position.x, camera.position.y - player.height / 2, camera.position.z),
                new THREE.Vector3(0.6, player.height * 0.9, 0.6)
            );

            // Determine the range of world blocks to check for collision with the player's bounding box
            const minX = Math.floor(playerBox.min.x);
            const maxX = Math.ceil(playerBox.max.x);
            const minY = Math.floor(playerBox.min.y);
            const maxY = Math.ceil(playerBox.max.y);
            const minZ = Math.floor(playerBox.min.z);
            const maxZ = Math.ceil(playerBox.max.z);

            // Iterate over all potentially intersecting blocks
            for (let x = minX; x < maxX; x++) {
                for (let y = minY; y < maxY; y++) {
                    for (let z = minZ; z < maxZ; z++) {
                        if (getWorldBlock(x, y, z) !== 0) { // If it's a solid block (not air)
                           // Create a bounding box for the current world block
                           const blockBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5), new THREE.Vector3(1,1,1));
                           // Check for intersection between player and block
                           if(playerBox.intersectsBox(blockBox)) {
                               return true; // Collision detected
                           }
                        }
                    }
                }
            }
            return false; // No collision detected
        }

        // Handles window resizing to keep the renderer and camera aspect ratio correct
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
